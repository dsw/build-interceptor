<html>
<head>
<title>Build Interceptor</title>
</head>
<body bgcolor=white>

<p><b>Summary:</b> Build Interceptor captures the .i files of any
project while it is built from source using the gcc tool-chain.

<p><b>Maintainer:</b> Daniel S. Wilkerson
<br><b>Developers:</b> <a href="http://www.cs.berkeley.edu/~quarl/">Karl Chen</a>

<p>Anyone who has tried this on a large scale will find out that it is
non-trivial to build a project from source and obtain the .i files
generated during the build process.  I give step-by-step instructions
on how to use the provided scripts to do this without *any*
modification to the build process of the project you are trying to
capture.

<p>This work was supported by professors <a
href=http://theory.stanford.edu/~aiken/>Alex Aiken</a> and <a
href=http://www.cs.berkeley.edu/~daw/>David Wagner</a> and was done at
UC Berkeley.

<ul>
<li><a
href="http://build-interceptor.tigris.org/files/documents/2710/22718/build-interceptor-2004.11.19.tar.gz">build-interceptor-2004.11.19.tar.gz</a> &nbsp; md5:
<code>
a4299ddab5ad0e3c7aecc53a5e750101
</code>
&nbsp;<b>NOTE:</b> Build interceptor has been improved substantially since
this release, but I haven't released another version yet as we are
still testing it.  <b>Feel free to just get the current Subversion
repository version as a guest user.</b>
</ul>

<h2>Introduction</h2>

<h3>Welcome!</h3>

<p>Build Interceptor is a collection of scripts for recording the .i
files generated during a build of C or C++ programs with the gcc
tool-chain.  No modification to the original build process is
necessary.

<h3>Limitations</h3>

<p>The method described here requires that you be root on your box so you
can replace the system cc1 and cc1plus programs, among others; this is
done so that the build process you are intercepting does not have to
be changed at all.  You can probably also get it to work by setting
environment variables such as GCC_EXEC_PREFIX.  I could not figure out
how to change the compiler proper (cc1) from gcc spec files.

<p>The previous version of this tool would not work with the gcc 3 series
as the preprocessor and compiler had been integrated; however since
then by looking through the source code I discovered the seemingly
undocumented flag "--no-integrated-cpp" which solves this problem.

<p>Compilers other than gcc are not supported.  Gcc 3.3 and 3.4 work;
gcc 3.2.3 seems to not work.

<h3>Background</h3>

<p>When gcc/g++ compiles, it pre-processes .c or .cc files to .i or .ii
files (respectively), compiles .i or .ii files to .s files, assembles
.s files to .o files, and links .o files to executables.  It
traditionally does all these stages with separate programs (new
versions of gcc complicate this by integrating preprocessing and
compilation), in particular the compiler-proper program being called
cc1 or cc1plus for C or C++ (respectively).

<h3>Basics of how the build interception works</h3>

<p>The cc1_interceptor.pl script captures the .i and .ii files generated
by the gcc compiler tool chain by replacing and imitating cc1.  It <ol>

   <li>copies the pre-processed input, the .i file, to a new file,

   <li>runs the real cc1 passing in the copy,

   <li>puts the fully-qualified filename of the copy into a string in
      the section ".note.cc1_interceptor" in the assembly output.

</ol>

<p>This name flows to the .o and then to the executable (the linker will
concatenate multiple occurrences of this section) where it can later
be retrieved using objdump; This is easier to do if you use Ben
Liblit's extract-section script which he ships as part of "The
Cooperative Bug Isolation Project" and which I include in this
project; see below for details.

<p>The build interceptor process works by first moving away the system
executables (using the Intercept.mk makefile, as root) and replacing
them with softlinks to the interception scripts provided.

<h3>Licensing</h3>

<p>All files in this directory tree and its subtrees are distributed
under the license in License.txt; please see that file for copyright
and terms of use.

<h2>Design</h2>

<h3>Simplicity</h3>

<p>There are other ways one might attempt build process interception.
This particular design has been chosen to avoid some problems that are
not at all obvious if you have not tried this before.  The salient
lesson of those other projects is that build-processes are very
complex and interception is hard to do without breaking them; testing
is very difficult because if something fails it is hard to know how
what went wrong or even if something went wrong.  The number one
concern of the design is therefore to keep things as simple and
non-intrusive as possible.

<p>Our design builds on the experience of the MOPS project and
Cooperative Bug Isolation Project (CBI), which I talk more about in
the Acknowledgments section below.

<h3>Staged interception</h3>

<p>We do not pipeline the build interception with any further analysis
of the generated .i files.  That is we just save the generated .i
files, we don't run an analysis right then; the MOPS project (below)
did attempt to analyze .i files as they were generated.  When a build
would fail, they assumed that their analysis had failed.  When we
later separated the interception from the analysis, we found that in
fact the interception was often failing but this was going undetected.

<p>Another reason to not separate them is that if your analysis does
fail, you often want to re-run it multiple times as you gradually
minimize the input, such as while using the delta file minimizer tool
(http://www.cs.berkeley.edu/~dsw/).  This is only possible if you have
already materialized the .i file somewhere separately.

<p>Basically a complex process should be staged if at all possible to
reduce complexity.

<h3>Metadata lives in data</h3>

<p>We do not attempt to keep metadata on build-process-generated files
anywhere outside the files themselves.  Early versions of the MOPS
projects attempted to put derived data from a .i file into another
file and then somehow maintain an association between the two.  This
was found to be impossible due to build processes moving files around
etc.

<p>All metadata for a file is inserted into the file in one way or
another, depending on the current language the file is in: at the
compile stage, it is inserted into the generated assembly (a trick
novel to build_interceptor) and at the link stage it is inserted into
the .o file using objcopy (a trick from MOPS and also CBI as well I
think).

<h3>Avoid long-range communication outside of data</h3>

<p>We do not attempt complex out-of-band communication between the
various sub-processes of gcc, which differs from both MOPS and CBI.
MOPS for example attempts to capture the preprocessing stage, analyze
it, and then insert the results in after the linking stage.  Getting
rid of this long-range dependency between stages greatly simplifies
things.

<p>We do by default insert the preprocessing output captured at the
start of the compilation stage into the .o file at the end of the
assembly stage.  This is pretty simple as the out of band data is the
preprocessing output which has been stored in a temporary file with a
name computed to not collide with others and located in a canonical
place; the name of this file is in-band, embedded in the file as it is
passed along.

<h3>Avoid parsing complex command-lines</h3>

<p>Similarly we manage to almost completely avoid parsing the
command-line arguments of gcc, though a few situations forced us to do
it a little.  Again, the simplification of the process is huge; we
only parse arguments of simple tools such as cc1 and collect2; their
command-lines are much simpler as another tool uses them, not a human.

<p>Something you might be tempted to do along these lines is to remove
-O* flags from the compile stage to speed things up, since perhaps you
are only interested in the .i files and not in actually using the
resulting executables.  Removing -O* from the compile stage alone will
not work, as if it has been passed to the preprocessing stage the
compile stage will fail to compile it due to various things having
been inlined.  I suppose it would work to remove it from all stages,
probably using the gcc spec file mechanism, but I don't consider it
worth the complexity and possibility of failure.

<h2>Goals and amount of interception</h2>

<h3>Only use what you need</h3>

<p>What tools must be intercepted during the build process depends on
what your goal is.  You can turn off the interception of tools by
removing them from intercept.progs after it is built.

<h3>File-by-file</h3>

<p>For a file-by-file analysis of source code, you simply need the source
files after pre-processing.  It is sufficient to just intercept
cc1/cc1plus and (after running reorg_build.pl) look at the resulting
.i files.

<p>Note that even if you do not intercept cpp/cpp0/tradcpp0/gcc -E, the
gcc spec file will tell gcc to not pass -P which means there should
always be line directives in the .i file.  So if your analysis finds
an error, it can always map it back to the original source line.

<h3>Whole-program</h3>

<p>For a whole-program analysis of all the source in the package, you
need to know for each executable which .i files went into it.  Each
such executable (and any other files produced by the linker) will
result in a .ld file which lists all the .i files that went into it
that were compiled during the build.

<p>For a really whole-program analysis that also looks at libraries, or
if you wanted to modify the .i files, recompile, and re-link, you need
to know *all* the .o files that went into an executable.  For this you
will need to also intercept collect2, which is implemented; however
the script reorg.pl would also have to be extended to extract the
linker --trace output, but this is straightforward.

<p>You would want to intercept 'as' to make a mapping between .s files
output by cc1/cc1plus and .o files linked together by the linker as
well as the command-line.  It would probably be best to insert the
metadata after assembly using objcopy, just as with collect2.

<h3>Source-to-source</h3>

<p>If you wanted to do a source-to-source transformation on the
original source you would need the preprocessing command line as well,
and so would have to intercept cpp/cpp0/tradcpp0/gcc -E; probably you
would insert the metadata into the file as the initializer of a global
string variable with an unusual name.

<p>"Replaying" a build process from the interception record is probably
trickier than one might at first imagine: build processes sometimes do
strange things such as move files around.  You would have to intercept
mv and perhaps rm etc.  I have not done this but it is not hard given
the infrastructure.  One thing you will likely want is for the build
process to be deterministic, so the make interceptor removes -j from
the command line; try out the TestMake.mk makefile with and without
it.

<h3>Miscellaneous difficulties with gcc layering</h3>

<p>You might have to experiment to figure out exactly what which layer to
intercept.  I am using gcc 3.4.0 and it seems that neither cpp nor gcc
-E call each other nor a program called cpp0, which seems to not exist
anymore; however perhaps gcc 2.95.3 does.  Similarly, ld does not call
collect2, though the gcc source code suggests in a comment that they
are interchangeable; why do the both exist?  To assist in this
experimentation, each interceptor script prints at the start its 1)
name, 2) parent process id, 3) own process id and 4) arguments all to
standard error (this may have been commented out, just uncomment).

<h2>Using the scripts</h2>

<h3>Setup</h3>

<p>One-time initial setup of build_interceptor.
<pre>
cd; cd build_interceptor
</pre>

<p>The makefile will build interceptor.specs for you according to your
auto-detected gcc version, however you might need to hack on it
anyway.  For example on gcc 3.4 one line has to look like this:
<pre>
%&lt;P %(cpp_options_old0)
</pre>
<p>whereas on earlier versions of gcc, it has to look like this:
<pre>
%{&lt;P} %(cpp_options_old0)
</pre>

<p>Build the intercept.progs and other support files.  If you run "make all"
without first running "make setup-default-gcc*", make will explain that you
need to do so.
<pre>
make setup-default-gcc.auto all
</pre>
The above will auto-detect the version of gcc that "gcc" runs.  If this does
not work correctly, explicitly specify the version with
<pre>
make setup-default-gcc-VERSION all
</pre>
where VERSION is the version of gcc, e.g.
<pre>
make setup-default-gcc-3.4 all
</pre>

<p>Now check that the files you want to intercept are generated in
intercept.progs.  You can change this file if you need to, but only
do it while build interception is off!  Otherwise you can get into
an inconsistent state.

<p>Make a place to put the .i files.
<pre>
cd
mkdir ball_preproc
ln -s ball_preproc preproc
</pre>

<h3>Interception</h3>

<p>Move your system gcc to gcc_orig and link gcc to gcc_interceptor.pl.
NOTE: it is important to be in $HOME/build_interceptor so that `pwd`
works below; $HOME will become '/root' once you su.
<pre>
cd; cd build_interceptor
su
make -f Intercept.mk on
</pre>
<p>You could exit the root shell now, but I find it easier to instead
just leave one shell open as root for turning interception on and
off and do user things in another shell.
<pre>
exit # the root shell
</pre>

<p>At any time you can check the interception state.
<pre>
make -f Intercept.mk
</pre>
<p>If you are intercepting make as well and you want to avoid running
the intercepted make, you can do this while interception is on.
<pre>
make_orig -f Intercept.mk
</pre>

<p>Build your project.

<p>If you mess up and need to start over again, just do this.
<pre>
rm -rf preproc/*
</pre>
<p>If you want to build two different projects and capture both, just
move the link.
<pre>
mkdir ball_preproc2
ln -s ball_preproc2 preproc
</pre>

<p>Before compiling anything else with gcc:
<p>1) Make the data read-only.
<pre>
cd
chmod -R a-w ball_preproc
</pre>
<p>2) Point the preprocessor capture at another file.
<pre>
mkdir preproc_junk
ln -s preproc_junk preproc
</pre>

<p>When you are done, put gcc back where it was.
<pre>
cd; cd build_interceptor
su
make -f Intercept.mk off
exit # the root shell
</pre>

<h3>Extraction</h3>

<p>There are two ways to find the intercepted .i files.  The first is
that they are down in $HOME/preproc.  The second is that they are
embedded into the ELF files.  You can get them out that way as
follows.

<pre>
extract_section.pl .note.cc1_interceptor a.out
</pre>

<p>Which prints out some metadata we inserted into the ELF.
<pre>
(
        . . .
        md5:a78dd86286867621359f8629a7bad88e
)
</pre>

<p>Use this to print out the .i file.
<pre>
extract_section.pl .file.a78dd86286867621359f8629a7bad88e a.out
</pre>

<h3>Weaknesses / Bugs</h3>

<p>The primary assumption is that there is a binary file gcc-VERSION
and that all other names such as "gcc" or "cc" are symbolic links (not
hard-links) to gcc-VERSION.  If this is not the case things will not
work.  In particular this assumption fails for Slackware.

<p>Using this assumption, build-Interceptor gets the gcc version at
run time from the binary name.  If you have multiple gcc versions
installed simultaneously, they must be named gcc-x.y
(e.g. /usr/bin/gcc-3.4) for this version detecting to work.

<p>Build-interceptor changes ongoingly to deal with various usage
scenarios.  There are some old scripts lying around that I don't to
get rid of but that are unlikely to work out of the box.  If I don't
explicitly mention that you should use a script, then it is not
guaranteed to work.

<h3>Files</h3>

<p>To simplify things, the scripts make some assumptions about what files
and directories are where.  I list them here; all are assumed to be
under $HOME.<ul>

<li><code>ball_preproc</code> Where the captured preprocessing output of
cc1_interceptor.pl goes.

<li><code>preproc</code> Link to ball_preproc.

</ul>

<h2>Acknowledgments</h2>

<p>This work was supported by professors <a
href=http://theory.stanford.edu/~aiken/>Alex Aiken</a> and <a
href=http://www.cs.berkeley.edu/~daw/>David Wagner</a> and was done at
UC Berkeley.

<p>I used code and ideas for build-process interception from two
different previous projects that dealt with this same problem. <ul>

<li>The <a href="http://www.cs.berkeley.edu/~liblit/sampler/">"The
Cooperative Bug Isolation Project"</a> by Ben Liblit

<li>The <a href="http://sourceforge.net/projects/mopscode">MOPS</a>
project by Hao Chen where he and Geoff Morrison in particular worked
on the build-process interception aspect.

</ul>

<p>The idea of inserting metadata into an unused section in ELF .o files
was borrowed from Ben and Hao.  I extended it back to the assembly
stage.

<p>Ben Liblit, Hao Chen, John Kodumal, and Simon Goldsmith contributed to
the discussions leading to these scripts.  Thanks especially to Simon
Goldsmith for proof-reading this Readme [I of course take
responsibility for any remaining mistakes].

<p>Thanks to Andy Begel for his in-depth explanation of dynamic linking
under various circumstances and operating systems.

<h2>&nbsp;</h2>

</body>
</html>
