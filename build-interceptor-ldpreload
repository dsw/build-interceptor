#!/usr/bin/perl

# $Id$

# This script implements Build-Interceptor LD_PRELOAD mode (see
# doc/modes.txt).
#
# It is the user entry point for LD_PRELOAD mode as well as an intermediate
# script for intercepting child processes.

use strict;
use warnings;
use FindBin;
use lib "${FindBin::RealBin}";
use Cwd;
use File::Spec;

my $LIB_DIR = "$FindBin::RealBin/lib/build-interceptor";
my $ETC_DIR = "$FindBin::RealBin/rc";

my $intercept_progs_filename = "$ETC_DIR/intercept.progs";
my $preload_lib_filename = "$LIB_DIR/build-interceptor.so";

if (!-f $intercept_progs_filename) {
    # TODO: allow intercept.progs to live in a different directory
    die "$0: couldn't find $intercept_progs_filename.\n";
}

if (! -f $preload_lib_filename) {
    die "$0: couldn't find $preload_lib_filename.\n";
}

if (scalar(@ARGV) < 1) {
    die "syntax: $0 program args...\n";
}

clean_ld_preload();

my $program = shift @ARGV;

if ($program !~ m,/,) {
    my $program1 = which($program);
    if (!$program1) {
        die "$0: can't find $program\n";
    }
    $program = $program1;
}

if (!-x $program) {
    die "$0: $program not executable\n";
}

$program = canonpath_except_file($program);

# Check if it's on our list of programs to intercept.
my $interceptor = get_interception($program);

if ($interceptor) {
    # Yes, we do want to intercept this program; no more LD_PRELOAD.
    if (! -x $interceptor) {
        die "$0: interceptor $interceptor not executable\n";
    }
    unshift(@ARGV, $interceptor,
            '--build-interceptor-mode', 'LD_PRELOAD',
            '--build-interceptor-program', $program);
} else {
    # No, don't intercept this program.
    unshift(@ARGV, $program);
    #
    # But *do* use ld_preload so we can intercept its children!
    add_ld_preload();
}

exec { $ARGV[0] } @ARGV;
die "$0: failed to exec $ARGV[0]\n";


# Canonicalize the directory component of a filename.
sub canonpath_except_file {
    my ($prog) = @_;
    my ($vol,$dir,$file) = File::Spec->splitpath($prog);
    my $basedir = File::Spec->catpath($vol, $dir, "");
    return File::Spec->catfile(Cwd::abs_path($basedir), $file);
}

sub get_interception {
    my ($program0) = @_;
    my $f = IO::File->new($intercept_progs_filename, 'r') or die "$0: couldn't read $intercept_progs_filename\n";
    local $_;
    while ($_ = <$f>) {
        chomp;
        m,^(/.+?)=(/.+)$, or die "bad line $_ from $intercept_progs_filename";
        my $program = $1;
        my $interceptor = $2;
        if ($program eq $program0) {
            return $interceptor;
        }
    }
    return;
}

sub clean_ld_preload {
    my $ld_preload = $ENV{BUILD_INTERCEPTOR_ORIG_LD_PRELOAD} = $ENV{LD_PRELOAD};
    # remove existing $PRELOAD, if any.
    $ld_preload =~ s/ /:/g;
    $ld_preload =~ s/::/:/g;
    $ld_preload = ":$ld_preload:";
    $ld_preload =~ s/:$preload_lib_filename://g;

    $ld_preload =~ s/^:+//;
    $ld_preload =~ s/:+$//;
    $ENV{LD_PRELOAD} = $ld_preload;
}

sub add_ld_preload {
    my $ld_preload = $ENV{LD_PRELOAD};
    # add new preload
    $ld_preload = "$preload_lib_filename:$ld_preload";

    # remove trailing ':' if empty.
    $ld_preload =~ s/:$//;

    $ENV{LD_PRELOAD} = $ld_preload;

    # needed by preload_lib to get back here.
    $ENV{BUILD_INTERCEPTOR_LDPRELOAD} = File::Spec->rel2abs($0);
    # TODO: if installing, this should be hard-coded.
}

sub isprog {
    return 1 if -x $_[0] && !-d $_[0];
}

sub which {
    my ($x) = @_;
    if ($x =~ m,^/,) {
        return $x if isprog $x;
        return;
    }

    for my $dir (File::Spec->path()) {
        my $f = File::Spec->catfile($dir, $x);
        return $f if isprog($f);
    }
}
