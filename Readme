Readme; see oink/License.txt for copyright and terms of use
-*-text-*-

                          Build Interceptor

                         Daniel S. Wilkerson
                   http://www.cs.berkeley.edu/~dsw/

Introduction ****************

Welcome!  Build Interceptor is a collection of scripts for recording
the .i files generated during a build of C or C++ programs with the
gcc toolchain.  No modification to the original build process is
necessary.

Limitations ****

The method described here requires that you be root on your box so you
can replace the system cc1 and cc1plus programs, among others; this is
done so that the build process you are intercepting does not have to
be changed at all.  You can probably also get it to work by setting
environment variables such as GCC_EXEC_PREFIX.  I could not figure out
how to change the compiler proper (cc1) from gcc spec files.

The previous version of this tool would not work with the gcc 3 series
as the preprocessor and compiler had been integrated; however since
then by looking through the source code I discovered the seemingly
undocumented flag "--no-integrated-cpp" which solves this problem.

Compilers other than gcc are not supported.

Background ****

When gcc/g++ compiles, it pre-processes .c or .cc files to .i or .ii
files (respectively), compiles .i or .ii files to .s files, assembles
.s files to .o files, and links .o files to executables.  It
traditionally does all these stages with separate programs (new
versions of gcc complicate this by integrating preprocessing and
compilation), in particular the compiler-proper program being called
cc1 or cc1plus for C or C++ (respectively).

Basics of how the build interception works ****

The cc1_interceptor.pl script captures the .i and .ii files generated
by the gcc compiler tool chain by replacing and imitating cc1.  It

   1) copies the pre-processed input, the .i file, to a new file,

   2) runs the real cc1 passing in the copy,

   3) puts the fully-qualified filename of the copy into a string in
      the section ".note.cc1_interceptor" in the assembly output.

This name flows to the .o and then to the executable (the linker will
concatenate multiple occurrences of this section) where it can later
be retrieved using objdump; This is easier to do if you use Ben
Liblit's extract-section script which he ships as part of "The
Cooperative Bug Isolation Project" and which I include in this
project; see below for details.

The build interceptor process works by first moving away the system
executables (using the Intercept.mk makefile, as root) and replacing
them with softlinks to the interception scripts provided.

Licensing ****************

All files in this directory tree and its subtrees are distributed
under the license in License.txt; please see that file for copyright
and terms of use.

Using the scripts ****************

These scripts were originally written to capture the .i files
generated when building the Red Hat Linux 7.3 distribution from source
as a test for the Elsa/Oink C/C++ front end and analysis tools.  The
first release of build_interceptor used as an example of how to use
these scripts the process of building Red hat 7.3 from source and
capturing the .i files.  Those instructions are still available in
Readme_RedHat7.3.

# One-time initial setup of build_interceptor.
cd; cd build_interceptor
make
# Now check that the files you want to intercept are generated in
# intercept.files.  You can change this file if you need to, but only
# do it while build interception is off!  Otherwise you can get into
# an inconsistent state.

# Make a place to put the .i files.
cd
mkdir ball_preproc
ln -s ball_preproc preproc

# Move your system gcc to gcc_orig and link gcc to gcc_interceptor.pl.
# NOTE: it is important to be in $HOME/build_interceptor so that `pwd`
# works below; $HOME will become '/root' once you su.
cd; cd build_interceptor
su
make -f Intercept.mk on
# You could exit the root shell now, but I find it easier to instead
# just leave one shell open as root for turning interception on and
# off and do user things in another shell.
exit # the root shell

# At any time you can check the interception state.
make -f Intercept.mk

# Build your project.

# If you mess up and need to start over again, just do this.
rm -rf preproc/*
# If you want to build two different projects and capture both, just
# move the link.
mkdir ball_preproc2
ln -s ball_preproc2 preproc

# Before compiling anything else with gcc:
# 1 - Make the data read-only.
cd
chmod -R a-w ball_preproc
# 2 - Point the preprocessor capture at another file
mkdir preproc_junk
ln -s preproc_junk preproc

# When you are done, put gcc back where it was.
cd; cd build_interceptor
su
make -f Intercept.mk off
exit # the root shell

# Run reorg on the output.
# FIX: finish this.

Files ****

To simplify things, the scripts make some assumptions about what files
and directories are where.  I list them here; all are assumed to be
under $HOME.

ball_preproc: Where the captured preprocessing output of
cc1_interceptor.pl goes.

preproc: Link to ball_preproc.

ball_build: The root of the tree where the source RPMs get built.

ball: The directory that results from reorganizing the captured .i
files according to the .note.cc1_im sections left behind in the
executables and .o files.

ball_fail_c.files and ball_fail_cc.files: The files where gcc_all.pl
puts the list of .i files that fail to build with gcc after being
captured by the build process.

Design ****************

Our design builds on the experience of the MOPS project and
Cooperative Bug Isolation Project (CBI), which I talk more about in
the Acknowledgments section below.

There are other ways one might attempt build process interception.
This particular design has been chosen to avoid some problems that are
not at all obvious if you have not tried this before.  The salient
lesson of those other projects is that build-processes are very
complex and interception is hard to do without breaking them; testing
is very difficult because if something fails it is hard to know how
what went wrong or even if something went wrong.  The number one
concern of the design is therefore to keep things as simple and
non-intrusive as possible.

1 - We do not pipeline the build interception with any further
analysis of the generated .i files.  That is we just save the
generated .i files, we don't run an analysis right then; the MOPS
project (below) did attempt to analyze .i files as they were
generated.  When a build would fail, they assumed that their analysis
had failed.  When we later separated the interception from the
analysis, we found that in fact the interception was often failing but
this was going undetected.

Another reason to not separate them is that if your analysis does
fail, you often want to re-run it multiple times as you gradually
minimize the input, such as while using the delta file minimizer tool
(http://www.cs.berkeley.edu/~dsw/).  This is only possible if you have
already materialized the .i file somewhere separately.

Basically a complex process should be staged if at all possible to
reduce complexity.

2 - We do not attempt to keep metadata on build-process-generated
files anywhere outside the files themselves.  Early versions of the
MOPS projects attempted to put derived data from a .i file into
another file and then somehow maintain an association between the two.
This was found to be impossible due to build processes moving files
around etc.

All metadata for a file is inserted into the file in one way or
another, depending on the current language the file is in: at the
compile stage, it is inserted into the generated assembly (a trick
novel to build_interceptor) and at the link stage it is inserted into
the .o file using objcopy (a trick from MOPS and also CBI as well I
think).

3 - We do not attempt out-of-band communication between the various
sub-processes of gcc, which differs from both MOPS and CBI.  MOPS for
example attempts to capture the preprocessing stage, analyze it, and
then insert the results in after the linking stage.  Getting rid of
this long-range dependency between stages greatly simplifies things.

4 - Similarly we do not attempt to parse the command-line arguments of
gcc.  Again, the simplification of the process is huge; we only parse
arguments of simple tools such as cc1 and collect2.

Something you might be tempted to do along these lines is to remove
-O* flags from the compile stage to speed things up, since perhaps you
are only interested in the .i files and not in actually using the
resulting executables.  Removing -O* from the compile stage alone will
not work, as if it has been passed to the preprocessing stage the
compile stage will fail to compile it due to various things having
been inlined.  I suppose it would work to remove it from all stages,
probably using the gcc spec file mechanism, but I don't consider it
worth the complexity and possibility of failure.

Acknowledgments ****************

I used code and ideas for build-process interception from two
different previous projects that dealt with this same problem.

    The "The Cooperative Bug Isolation Project"
    (http://www.cs.berkeley.edu/~liblit/sampler/) by Ben Liblit

    The MOPS project (http://sourceforge.net/projects/mopscode) by Hao
    Chen where he and Geoff Morrison in particular worked on the
    build-process interception aspect.

The idea of inserting metadata into an unused section in ELF .o files
was borrowed from Ben and Hao.  I extended it back to the assembly
stage.

Ben Liblit, Hao Chen, John Kodumal, and Simon Goldsmith contributed to
the discussions leading to these scripts.  Thanks especially to Simon
Goldsmith for proof-reading this Readme [I of course take
responsibility for any remaining mistakes].
