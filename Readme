Readme; see oink/License.txt for copyright and terms of use
-*-text-*-

                          Build Interceptor

                         Daniel S. Wilkerson
                   http://www.cs.berkeley.edu/~dsw/

Introduction ****************

Welcome!  Build Interceptor is a collection of scripts for recording
the .i files generated during a build.  No modification to the original
build process is necessary.

Background ****

When gcc/g++ compiles, it pre-processes .c or .cc files to .i or .ii
files (respectively), compiles .i or .ii files to .s files, assembles
.s files to .o files, and links .o files to executables.  It
traditionally does all these stages with separate programs (new
changes complicate this; see below), in particular the compiler-proper
program being called cc1 or cc1plus for C or C++ (respectively).

Basics of how the build interception works ****

The cc1_interceptor.pl script captures the .i and .ii files generated
by the gcc compiler tool chain by replacing and imitating cc1.  It

   1) copies the pre-processed input to a new file,

   2) runs the real cc1 passing in the new copy,

   3) puts the fully-qualified filename of the copy into a string in
      the section ".note.cc1_im" in the assembly output.

This name flows to the .o and then to the executable (the linker will
concatenate multiple occurrences) where it can later be retrieved
using objdump; This is easier to do if you use Ben Liblit's
extract-section script which he ships as part of "The Cooperative Bug
Isolation Project"; see below.

Use this script by moving your system cc1 and cc1plus to old-cc1 and
old-cc1plus respectively and then making a link to this script in
its old location as cc1 (it is ok to link both to this same script
as it figures out how it was called); A similar effect can probably
be achieved with gcc spec files or environment variables.  According
to Ben, newer gcc versions combine the preprocessing and compiling
stages by default, so you may have to do more to separate them again
so that this script will work.

Licensing ****************

All files in this directory tree and its subtrees are distributed
under the license in License.txt; please see that file for copyright
and terms of use.

Using the scripts ****************

These scripts were originally written to capture the .i files
generated when building the Red Hat Linux 7.3 distribution from source
as a test for the Elsa/Oink C/C++ front end and analysis tools.  Both
of the resulting data and Oink can be downloaded from my homepage
given above; I also provide a link to Elsa there.

As an example of how to use these scripts, I describe how to reproduce
those .i files.  That is, we detail the process of building Red hat
7.3 from source and capturing the .i files almost as it was done, but
with the simplifying benefit of hindsight.

Please note that this is my recollection of what I did and that I did
not repeat the whole thing just to check that every script is exactly
right, as the whole thing takes quite a while.

This process and the scripts provided are quite generic and can be
used for any project; however, many artifacts of the original usage
remain in some of the scripts, such as lists of package names.  You
will have to fix them here and there for your project.  Feel free to
send me the improvements.

* Install Red Hat 7.3

Buy a new disk.

Obtain the Red Hat 7.3 ISOs (I have a link to them posted; they can be
hard to find).

Burn them on CDs.

Install Red Hat 7.3 from CD onto the new disk.

Put the source RPMs from the source disks into /usr/src/redhat/SRPMS.

* Intercept build process

Rename your two cc1's to old-cc1; Note: I describe everything for cc1,
but do it for the parallel cc1plus programs as well.

Something like this will find them.  I used locate but you have to
build the database first.
  find /usr -follow -regex '.*cc1' 2>/dev/null

On Red Hat 7.3, there are four.  Thee two are just links to the other
two, so leave them (and their sibling cc1plus) alone.
  /usr/i386-glibc21-linux/lib/gcc-lib/i386-redhat-linux/2.96/cc1
    -> ../../../../../lib/gcc-lib/i386-glibc21-linux/egcs-2.91.66/cc1
  /usr/lib/gcc-lib/i386-redhat-linux/egcs-2.91.66/cc1
    -> ../../i386-glibc21-linux/egcs-2.91.66/cc1

So just rename these two (and the parallel cc1plus files):
  /usr/lib/gcc-lib/i386-redhat-linux/2.96/cc1
  /usr/lib/gcc-lib/i386-glibc21-linux/egcs-2.91.66/cc1

Now make a softlink the old names to the cc1_interceptor.pl script
provided.

Make a directory to keep the .i files generated during the build.
  mkdir ball_preproc
Make a softlink to it from $HOME/preproc, the directory named in
cc1_interceptor.pl.
  ln -s ball_preproc preproc

* Build

Make a directory where Red Hat will be built.
  mkdir ball_build

IMMEDIATELY Build everything; do not use gcc for anything else first
as the .i files will end up in the preproc directory.  This takes
about 19 hours on my 1.7 GHz AMD with 3.5 Gig RAM.
  ./just_build.pl

IMMEDIATELY before compiling anything else with gcc:
  chmod -R a-w ball_preproc ball_build

Also remove the softlinks above and rename old-cc1 to cc1.
  mkdir preproc_junk
  ln -s preproc_junk preproc

Rename the system old-cc1 and old-cc1plus files to their original
names and remove (or just move to another directory) the softlinks to
them.

Only 92.5% of the packages say that they build successfully according
to the return value of rpmbuld.  I don't yet understand how the simple
build process interception that I do can cause so many packages to
fail; if you find out, let me know.  These packages that fail to build
have not been included in this release.

* Count source lines

The files pkgs_by_c_size.dat and pkgs_by_cpp_size.dat list each
package sorted by the number of .c and .cc (or other spellings) files
in a package, respectively.
  ./count_src.pl

Note that the script prints the C and C++ sizes on one line, whereas
the pkgs_by_c[pp]_size.dat files I provide are the same data split
into two files.

* Reorganize

Now it helps greatly to reorganize the files left in ball_preproc
according to the information left in the executables and library files
(.o, .so, or those inside .a) left by the build process in ball_build.
Yes, I did check that the section added to the assembly (called
".note.cc1_im") does survive in the .o, .so, or executable even if it
is stripped.

Make a link to Ben Liblit's extract_section.pl script.  This script is
used to the extraction of the section from the executable and library
files.  I find it strange that neither objdump, objcopy nor readelf
have this as a command-line option, but that fact necessitates the
existence of this script.
  ln -s <this directory>/extract_section.pl extract_section.pl

Make a directory for the reorg databall output.
  mkdir ball

Run
  ./reorg_build.pl

Now you have a file $HOME/ball that is partitioned by package.  In
each package directory there are .i files for pre-processed C files,
.ii files for pre-processed C++ files, and .ld files which list all the
filenames that are linked together to make a .o, .so or executable
file; You need these so you know which files to analyzed together
when doing a whole-program analysis.

* Check for configure files

Some files generated as part of the configure stage of the build
process of some packages can be deliberately perverse; you don't want to
analyze them.  Run the script to check what is a configure or
configtemp file:
  ./find_config.pl

When I ran it I found 3 files that were very simple and I just left
them in the .i files as they were legal.

* Check that gcc builds them again

Run the installed gcc 2.96 over all the .i files to verify that they
build.  Be sure you no longer have your system cc1 or cc1plus pointing
at cc1_interceptor before doing this.
  ./gcc_all.pl

Of those, two packages have files that fail when you run gcc on them
again(!):
  htdig-3.2.0-2.011302
  glibc-2.2.5-34

How this can be I don't know; If I had written rpmbuild and a
reasonable build process for a package then if any of the files failed
to build I would have had the whole process halt.  Evidently, some
packages fail to build some files but the build keeps going anyway
(!?).  If you find out what this is, let me know.

I have included these packages in the release anyway, as only a few
files in the packages fail and rpmbuild said their builds succeeded;
you are free to delete them from the list of packages you run
experiments on.

* If you re-release

I am not a lawyer; however it seems to me that if you are going to
release the .i files you generate that, since they are derived works
from the original source, you have to provide with them the license
file with which the package came.  I have done this by simply
including all the .src.rpm-s and referring the reader to to them.

Files ****

To simplify things, the scripts make some assumptions about what files
and directories are where.  All are assumed to be under $HOME.

ball_preproc: Where the captured preprocessing output of
cc1_interceptor.pl goes.

preproc: Link to ball_preproc.

ball_build: The root of the tree where the source rpms get built.

ball: The directory that results from reorganizing the captured .i
files according to the .note.cc1_im sections left behind in the
executables and .o files.

ball_fail_c.files and ball_fail_cc.files: The files where gcc_all.pl
puts the list of .i files that fail to build with gcc after being
captured by the build process.

Acknowledgments ****************

I used code and ideas for build-process interception from two
different previous projects dealing with this problem:

    The "The Cooperative Bug Isolation Project"
    (http://www.cs.berkeley.edu/~liblit/sampler/) by Ben Liblit

    The MOPS project (http://sourceforge.net/projects/mopscode) by Hao
    Chen where he and Geoff Morrison in particular worked on the
    build-process interception aspect.

The idea of inserting metadata into an unused section in ELF .o files
was borrowed from Ben and Hao.  I extended it back to the assembly
files.

Ben Liblit, Hao Chen, John Kodumal, and Simon Goldsmith contributed to
the discussions leading to these scripts.  Thanks especially to Simon
Goldsmith for proof-reading this Readme [I of course take
responsibility for any remaining mistakes].
